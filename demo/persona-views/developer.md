# Developer: 5-Minute Deep-Dive

**One-line pitch:** Business observability means your code IS your status update.

**Pain addressed:** $475K/yr (enterprise) for redundant status updates across 3 tools + AI context re-explanation

---

## Pre-Demo Checklist

- [ ] Grafana running at http://localhost:3000
- [ ] Tempo datasource configured and receiving spans
- [ ] Historical demo data loaded (run `demo/setup_demo_env.sh`)
- [ ] Example git repo with task-ID commits available

---

## Talking Points & Queries

### Minute 1: "Your Commit Is Your Status Update" (1:00)

**Setup:** Show a terminal with a git commit message containing a task ID.

**Talking point:**
> "Every time you commit with a task ID in the message, ContextCore derives the task status automatically. No Jira update. No Slack message. Your work generates its own telemetry."

**Query — Find status changes from commits:**
```
# TraceQL: Find task status transitions triggered by artifacts
{span.task.id != "" && span.task.status.source = "artifact"} | select(span.task.id, span.task.status, span.artifact.type)
```

**What to show:** A task span in Tempo where status changed from `in_progress` to `review` because a PR was opened.

### Minute 2: "AI Memory That Persists" (2:00)

**Talking point:**
> "Every decision an AI agent makes is stored as an insight span. Next session, it queries Tempo instead of re-discovering context. Your agent remembers what it learned."

**Query — Retrieve agent decisions from last session:**
```
# TraceQL: Find high-confidence decisions from recent sessions
{span.insight.type = "decision" && span.insight.confidence >= 0.8} | select(span.insight.summary, span.insight.confidence, span.insight.evidence)
```

**What to show:** Insight spans with decision summaries, confidence scores, and evidence links.

### Minute 3: "Agent Constraints You Define" (3:00)

**Talking point:**
> "You define the rules. Agents follow them. Every constraint check is logged — you can audit what the agent considered and why it chose a path."

**Query — Find constraint evaluations:**
```
# TraceQL: Agent constraint checks
{span.agent.constraint.evaluated = true} | select(span.agent.constraint.name, span.agent.constraint.result, span.agent.action)
```

**What to show:** A constraint evaluation span showing the agent checked "no direct DB writes" and routed through the API instead.

### Minute 4: "Decision Visibility" (4:00)

**Talking point:**
> "Every AI decision logged with confidence and evidence. Not a black box — a glass box. You can query what Claude decided, why, and what alternatives it considered."

**Query — Decision audit trail:**
```
# TraceQL: All agent decisions for a specific task
{span.task.id = "DEMO-P1-GENERATE" && span.insight.type = "decision"}
```

**What to show:** Decision span details panel in Tempo — confidence score, evidence links, alternatives considered.

### Minute 5: "Zero Overhead Summary" (5:00)

**Talking point:**
> "You didn't update a ticket. You didn't write a status report. You committed code. Everything else was derived. That's business observability for developers."

**Visual:** Side-by-side: traditional workflow (commit + update Jira + post Slack + update wiki) vs. ContextCore (commit with task ID — done).

---

## Delivered Capabilities

| Capability | Maturity | What It Does |
|-----------|----------|--------------|
| `contextcore.status.auto_derive` | beta | Derive task status from Git commits/PRs/merges |
| `contextcore.agent.persistent_memory` | beta | AI decisions persist as OTel spans, queryable next session |
| `contextcore.agent.constraints` | beta | Human-defined rules agents must follow |
| `contextcore.agent.decision_visibility` | beta | Every AI decision logged with confidence + evidence |

---

## Fallback If Live Queries Fail

Use the pre-loaded historical data. All queries above work against the demo dataset generated by `setup_demo_env.sh`. If Tempo is slow, have screenshots of each query result ready in `demo/screenshots/`.
